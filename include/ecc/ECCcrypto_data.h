/*
 * Copyright 2019 NXP
 */

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holder nor the names of its contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON  ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 *
 * @file ECCcrypto_data.h
 *
 * @brief Test patterns for all crypto tests
 *
 */

#ifndef ECC_CRYPTO_DATA_H
#define ECC_CRYPTO_DATA_H

#define LENGTH_DOMAIN_PARAMS_256 32
#define LENGTH_DOMAIN_PARAMS_384 48

/** Size of "message" for hash */
#define HASH_MSG_SIZE         7

/* Dataset for signature verification tests */
/** Message is "message" */
static uint8_t test_ver_msg[HASH_MSG_SIZE] = {
		0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65
		};
/** 256-related dataset */
/** Hash of "message" */
static uint8_t test_ver_hash_256[LENGTH_DOMAIN_PARAMS_256] = {
		0x1D, 0x6D, 0x0C, 0x46, 0x2B, 0xF0, 0xFB, 0x1A,
		0xEA, 0x1C, 0xF7, 0x22, 0xFB, 0xF3, 0xD1, 0xCF,
		0x94, 0xA9, 0xFB, 0xE3, 0xB7, 0xF9, 0x79, 0x2B,
		0x98, 0x14, 0x59, 0xE4, 0x13, 0x0A, 0x53, 0xAB
		};
/** nistp256 */
/** Public key x coordinate for verification*/
static uint8_t test_ver_pubKey_x_nistp256[LENGTH_DOMAIN_PARAMS_256] = {
		0xC6, 0xA8, 0xBB, 0x62, 0xD9, 0x3E, 0x98, 0x0A,
		0xC4, 0x67, 0xC4, 0x4D, 0x38, 0x2C, 0xFB, 0x5E,
		0x7B, 0x40, 0x6A, 0x4E, 0x18, 0x14, 0x93, 0x80,
		0x1F, 0x4C, 0xCD, 0x68, 0x56, 0x9E, 0x6D, 0x3A
		};
/** Public key y coordinate for verification */
static uint8_t test_ver_pubKey_y_nistp256[LENGTH_DOMAIN_PARAMS_256] = {
		0x05, 0x2A, 0xA2, 0xE6, 0xEB, 0xD1, 0xE7, 0x73,
		0x7B, 0x9B, 0x79, 0x7C, 0xD4, 0x22, 0xF6, 0x17,
		0x66, 0x7A, 0x5A, 0xE3, 0x4E, 0xBD, 0xD9, 0xE6,
		0x52, 0xC0, 0x81, 0x93, 0xC2, 0x5F, 0x2D, 0x97
		};
/** Signature r value to verify*/
static uint8_t test_ver_sign_r_nistp256[LENGTH_DOMAIN_PARAMS_256] = {
		0x73, 0x5D, 0x9E, 0x22, 0x83, 0xCE, 0x2B, 0x1D,
		0xA6, 0xDA, 0x4A, 0x1C, 0x7A, 0x8D, 0x98, 0x21,
		0x4E, 0x9A, 0x9F, 0xC8, 0x6F, 0xC1, 0x0C, 0x51,
		0x93, 0x35, 0x52, 0x9D, 0xFF, 0xE9, 0x4B, 0x91
		};
/** Signature s value to verify*/
static uint8_t test_ver_sign_s_nistp256[LENGTH_DOMAIN_PARAMS_256] = {
		0x20, 0x14, 0xE4, 0x03, 0x57, 0xA4, 0x6E, 0x39,
		0xEA, 0x8B, 0x2E, 0xF1, 0xCB, 0x64, 0xE5, 0x6F,
		0xEF, 0x34, 0xD1, 0xDE, 0x93, 0x6B, 0xC8, 0x39,
		0x44, 0x86, 0xFD, 0x6F, 0x64, 0x26, 0x7A, 0xE6
		};
/*
 * Dataset for public key decompression tests
 */
/**
 * X-coordinate of public key
 * this will be the Y input for the test
 */
static uint8_t test_dec_pubKey_x_nistp256[LENGTH_DOMAIN_PARAMS_256] = {
		0x3c, 0x23, 0xa9, 0x76, 0x3a, 0x2f, 0x12, 0xbb,
		0x12, 0xe8, 0xde, 0xee, 0xb2, 0x69, 0x1c, 0x9e,
		0x79, 0x00, 0x30, 0xb7, 0xfc, 0x2e, 0xcf, 0xad,
		0xe3, 0x1e, 0x99, 0x51, 0x5b, 0x8b, 0xf1, 0x44
		};
/**
 * Y-coordinate of public key before decompression test:
 * this will be the Y input for the test.
 * The first byte is:
 *     - 0x00 if LSB of Y-coordinate is 0
 *     - 0x01 if LSB of Y-coordinate is 1
 */
static uint8_t test_dec_pubKey_y_nistp256[LENGTH_DOMAIN_PARAMS_256] = {
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		};
/**
 * Y-coordinate of public key: this is the expected output
 */
static uint8_t test_dec_pubKey_y_exp_nistp256[LENGTH_DOMAIN_PARAMS_256] = {
		0xed, 0x61, 0x30, 0x99, 0x9e, 0xe0, 0x2f, 0x23,
		0x10, 0x63, 0xf1, 0x40, 0x0c, 0x0a, 0xd1, 0x8c,
		0x02, 0x54, 0xbb, 0x24, 0xe8, 0x51, 0xaa, 0x52,
		0xdc, 0x4b, 0x27, 0x92, 0x4f, 0xcb, 0x06, 0x6d
		};
/**
 * Y-coordinate of public key before decompression test:
 * this will be the Y input for the negative test.
 */
static uint8_t test_dec_pubKey_y_neg_nistp256[LENGTH_DOMAIN_PARAMS_256] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		};

/*
 * Dataset for sha256 tests
 */
/** msg is "message" */
static uint8_t test_hash_msg_256[HASH_MSG_SIZE] = {
		0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65
		};
/** Expected hash of "message" using SHA256 */
static uint8_t test_hash_msg_exp_256[LENGTH_DOMAIN_PARAMS_256] = {
		0xab, 0x53, 0x0a, 0x13, 0xe4, 0x59, 0x14, 0x98,
		0x2b, 0x79, 0xf9, 0xb7, 0xe3, 0xfb, 0xa9, 0x94,
		0xcf, 0xd1, 0xf3, 0xfb, 0x22, 0xf7, 0x1c, 0xea,
		0x1a, 0xfb, 0xf0, 0x2b, 0x46, 0x0c, 0x6d, 0x1d
		};
/** msg is "messagg": this is used for negative test */
static uint8_t test_hash_msg_neg_256[HASH_MSG_SIZE] = {
		0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x67
		};

#endif
